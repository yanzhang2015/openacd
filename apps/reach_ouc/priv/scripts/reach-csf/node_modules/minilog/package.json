{
  "name": "minilog",
  "description": "Lightweight client & server-side logging with Stream-API backends and counting, timing support",
  "license": "MIT",
  "version": "2.0.6",
  "main": "lib/index.js",
  "dependencies": {
    "microee": "0.0.2"
  },
  "devDependencies": {
    "mocha": "*",
    "gluejs": "2.x"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mixu/minilog.git"
  },
  "author": {
    "name": "Mikito Takada",
    "email": "mikito.takada@gmail.com",
    "url": "http://blog.mixu.net/"
  },
  "keywords": [
    "logging",
    "sysadmin",
    "tools"
  ],
  "readme": "### Why?\n\n- Works in the browser and on the server\n- Themes for Node console output, and for the Chrome console (with fallbacks)\n- log.debug, log.info, log.warn, log.error\n- Associate log messages with a namespace and then filter by namespace and log level\n- Pipe to one or more backend streams at the same time\n- Backends:\n  - Node: Console, File (and all other WritableStreams), Redis\n  - Browser: Console, LocalStorage, jQuery.ajax\n\n## NEW! Minilog v2\n\nSee the docs at [http://mixu.net/minilog/](http://mixu.net/minilog/).\n\nI recently released Minilog v2. Heres' what's changed:\n\n- Better browser console output: due to changes in the internals, all parameters are now passed through internally as-is. This means that in browsers other than old IE, any objects and arrays that are logged as objects rather than stringified.\n- Better filtering: submodules can now set a default logging level, and configuring the filter is less painful.\n- There is an explicit `.disable()` function in addition to `.enable()`\n- In Chrome, we support theming the dev console output.\n- The internals are more consistent with idiomatic usage of [Streams2](http://blog.nodejs.org/2012/12/20/streams2/) (with 0.8.x backward compatibility provided by readable-stream): filters and formatters are transform streams rather than functions.\n- Interface compatibility with Node and browser consoles, since `Minilog.log()` proxies to `Minilog.debug()`\n\n## Pipes everywhere\n\nminilog is more convention than code. The logger is a [EventEmitter](http://nodejs.org/api/events.html), and backends are [Writable streams](http://nodejs.org/api/stream.html). Filters and formatters are duplex (readable + writable) streams.\n\nminilog works in Node, and in the browser:\n\n    // logs are scoped to a namespace for easy filtering (here, the namespace is \"app\")\n    var log = require('minilog')('app');\n    require('minilog').enable();\n\nin the browser (via a single exported global ```window.Minilog```):\n\n    <script src=\"dist/minilog.js\"></script>\n    <script>\n    var log = Minilog('app');\n    Minilog.enable();\n    </script>\n\nUsage:\n\n    // assuming you've done the two things above\n    log\n      .debug('debug message')\n      .info('info message')\n      .log('info message')\n      .warn('warning')\n      .error('this is an error message');\n\nOutput:\n\n![screenshot3](https://github.com/mixu/minilog/raw/master/test/example/screenshot3.png)\n\n\nTo log to the console:\n\n    require('minilog').enable();\n    // or .pipe(process.stdout), if you don't want the default formatting and filtering\n\nTo log into a file:\n\n    require('minilog').pipe(fs.createWriteStream('./temp.log'));\n\nYou can also log to Redis and over HTTP to a RESTful API, see the backends at the end of this page.\n\nYou can pipe to more than one endpoint if you want.\n\n## Installation\n\nFor Node:\n\n````shell\n$ npm install minilog\n````\n\nYou can find a ready-made file for the web in [`./dist/minilog.js`](https://raw.github.com/mixu/minilog/master/dist/minilog.js).\n\n### Upgrading from minilog v1\n\nEverything is now a pipe, which means that the `.format()` and `.filter()` functions are deprecated. Check out [the new filter mechanism docs](./filter.html). To apply a formatter, you should pipe the input into the formatter, and then pipe it to the desired backend:\n\n    var Minilog = require('minilog');\n\n    Minilog.pipe(Minilog.backends.console.formatWithStack)\n           .pipe(Minilog.backends.console);\n\n## Enabling logging\n\nMinilog output is suppressed by default. To enable logging, append `minilog=1` to the page URL:\n\n    http://www.example.com/index.html?minilog=1\n\nor call `Minilog.enable()` from the dev console or in code. On the browser, this also sets a value in LocalStorage so that logging is enabled on subsequent reloads. Call `Minilog.disable()` (*new in v2*) to stop logging.\n\n## Filtering\n\nMinilog supports filtering via the log scope name and the log level, as well as a number of nifty features. See [the filtering docs](http://mixu.net/minilog/filter.html) for more.\n\n## Formatting & themes\n\nMinilog supports themes and custom formatters, and comes several with built-in themes:\n\n![screenshot](https://github.com/mixu/minilog/raw/master/test/example/screenshot.png)\n\n![screenshot2](https://github.com/mixu/minilog/raw/master/test/example/screenshot2.png)\n\nTo enable a specific theme, pipe to the formatter and then to the console:\n\n    var Minilog = require('minilog');\n\n    Minilog\n        // formatter\n        .pipe(Minilog.backends.console.formatClean)\n        // backend\n        .pipe(Minilog.backends.console);\n\nHave a look at [./test/examples/themes_example.js](https://github.com/mixu/minilog/blob/master/test/example/themes_example.js).\n\nTo write your own formatter, have a look at the source code for the formatters - they inherit from `Minilog.Transform`.\n\n## Using Minilog as a console replacement\n\nIf you use an injected `console` object to log browser or Node.js activity, you can use Minilog instead: they have similar interfaces. Monolog provides a `log()` method, which proxies to `debug()`.\n\nSo for instance, the following snippet:\n\n```js\nfunction doThings(console) {\n    if (problem) {\n        console.error('problem');\n        return;\n    }\n    console.log('no problem');\n}\n```\n\nWorks seamlessly with Minilog instead of `console`:\n\n```js\nvar Minilog = require('minilog');\ndoThings(Minilog);\n```\n\n## Backends\n\nBackends are Writable streams which handle stringification.\n\n### Node: Console, Redis\n\nThe console backend is literally this (plus code for pretty printing log lines in various ways):\n\n    {\n      write: function(str) { process.stdout.write(str); }\n    }\n\nThe Redis backend is almost equally simple - it accepts ```client``` (an instance of node-redis) and ```key``` and uses rpush() to add to the list at the specified key.\n\n### Browser: Array, Console, jQuery, localStorage\n\nThe Array backend stores the log lines into an array. This is useful if you want to keep a list of all the log lines, e.g. for error reporting. Call ```.get()``` to get the array, and ```.clear()``` to empty it.\n\nThe Console backend makes sure that ```console.log``` is available. On IE8 and IE9, it tries to make the console a bit less aweful by using JSON.stringify to convert objects into strings (rather than \"[Object object]\").\n\nThe jQuery backend is useful for logging client-side log lines on the server side:\n\n- it sends new log messages as a POST request to a given URL every 30 seconds\n- if localStorage is available, logs are written to localStorage as well. This is helpful because it reduces the risk that you lose log lines just because the client navigates to a different page.\n- Unsent logs from localStorage are sent the next time the backend is activated (on your domain, localStorage is isolated).\n- No errors, even if localStorage is not available or jQuery is not defined (though no POST requests if no jQuery).\n\nThe localStorage backend just writes logs to the given ```key``` in localstorage.\n\nHave a look at the example server setup in `./test/examples/jquery_server.js`.\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/mixu/minilog/issues"
  },
  "_id": "minilog@2.0.6",
  "_from": "minilog@"
}
